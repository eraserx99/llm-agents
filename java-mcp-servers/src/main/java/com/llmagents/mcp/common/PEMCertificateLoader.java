package com.llmagents.mcp.common;

import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMKeyPair;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.List;

/**
 * Loads PEM-formatted certificates and private keys using BouncyCastle.
 * Compatible with certificates generated by Go's cert-gen utility.
 */
public final class PEMCertificateLoader {
    private static final Logger logger = LoggerFactory.getLogger(PEMCertificateLoader.class);

    static {
        // Register BouncyCastle as security provider
        if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
            Security.addProvider(new BouncyCastleProvider());
            logger.debug("BouncyCastle security provider registered");
        }
    }

    private PEMCertificateLoader() {
        // Utility class
    }

    /**
     * Load X.509 certificate from PEM file.
     *
     * @param certPath path to PEM certificate file
     * @return X509Certificate loaded from file
     * @throws IOException if file cannot be read
     * @throws CertificateException if certificate cannot be parsed
     */
    public static X509Certificate loadCertificate(Path certPath)
            throws IOException, CertificateException {
        logger.debug("Loading certificate from: {}", certPath);

        try (InputStream is = Files.newInputStream(certPath)) {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            X509Certificate cert = (X509Certificate) cf.generateCertificate(is);
            logger.info("Loaded certificate: subject={}, issuer={}",
                cert.getSubjectX500Principal().getName(),
                cert.getIssuerX500Principal().getName());
            return cert;
        }
    }

    /**
     * Load certificate chain from PEM file.
     * Supports files with multiple concatenated certificates.
     *
     * @param certPath path to PEM certificate file
     * @return list of X509Certificates loaded from file
     * @throws IOException if file cannot be read
     * @throws CertificateException if certificates cannot be parsed
     */
    public static List<X509Certificate> loadCertificateChain(Path certPath)
            throws IOException, CertificateException {
        logger.debug("Loading certificate chain from: {}", certPath);

        try (InputStream is = Files.newInputStream(certPath)) {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            List<X509Certificate> chain = new ArrayList<>();

            cf.generateCertificates(is).forEach(cert -> {
                if (cert instanceof X509Certificate x509) {
                    chain.add(x509);
                    logger.debug("Loaded certificate in chain: subject={}",
                        x509.getSubjectX500Principal().getName());
                }
            });

            logger.info("Loaded certificate chain with {} certificates", chain.size());
            return chain;
        }
    }

    /**
     * Load private key from PEM file.
     * Supports both PKCS#1 (RSA PRIVATE KEY) and PKCS#8 (PRIVATE KEY) formats.
     *
     * @param keyPath path to PEM private key file
     * @return PrivateKey loaded from file
     * @throws IOException if file cannot be read or key cannot be parsed
     */
    public static PrivateKey loadPrivateKey(Path keyPath) throws IOException {
        logger.debug("Loading private key from: {}", keyPath);

        try (PEMParser pemParser = new PEMParser(
                new InputStreamReader(Files.newInputStream(keyPath)))) {

            Object object = pemParser.readObject();
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter()
                .setProvider(BouncyCastleProvider.PROVIDER_NAME);

            PrivateKey privateKey;

            if (object instanceof PEMKeyPair pemKeyPair) {
                // PKCS#1 format (RSA PRIVATE KEY)
                privateKey = converter.getPrivateKey(pemKeyPair.getPrivateKeyInfo());
                logger.debug("Loaded PKCS#1 private key");
            } else if (object instanceof PrivateKeyInfo privateKeyInfo) {
                // PKCS#8 format (PRIVATE KEY)
                privateKey = converter.getPrivateKey(privateKeyInfo);
                logger.debug("Loaded PKCS#8 private key");
            } else {
                throw new IOException(
                    "Unsupported private key format in file: " + keyPath +
                    " (expected PEMKeyPair or PrivateKeyInfo, got " +
                    (object != null ? object.getClass().getName() : "null") + ")"
                );
            }

            logger.info("Loaded private key: algorithm={}, format={}",
                privateKey.getAlgorithm(), privateKey.getFormat());
            return privateKey;
        }
    }
}
