# Research: Java MCP Servers

**Feature**: Java MCP Servers (003-create-a-java)
**Date**: 2025-10-07
**Status**: Complete

## Overview
This document consolidates research findings for implementing three Java-based MCP servers (weather, datetime, echo) that are protocol-compatible with existing Go coordinator agents. All research tasks have been completed with decisions documented.

## Research Areas

### 1. MCP Java SDK Capabilities

**Question**: Which version of the MCP Java SDK should we use, and what are its capabilities for server implementation?

**Findings**:
- **Latest Version**: v0.14.1 (released October 6, 2025)
- **Maven Coordinates**: `io.github.modelcontextprotocol:mcp-server:0.14.1`
- **Server API**: Transport-agnostic design supporting blocking and non-blocking models
- **Transport Options**:
  - Jakarta Servlet (standard Java servlet API)
  - Spring WebFlux (reactive streams)
  - Spring WebMVC (traditional MVC)
  - STDIO (in-process communication)
- **Key Features**:
  - Supports MCP Streaming Protocol (SSE, Streamable HTTP)
  - Uses Project Reactor for async/streaming operations
  - Provides synchronous facade for blocking use cases
  - Built-in support for multiple in-flight requests
  - Notification support (fire-and-forget messages)

**Decision**: Use MCP Java SDK v0.14.1 with Jakarta Servlet transport

**Rationale**:
- Official SDK ensures protocol compliance with Go implementation
- Jakarta Servlet is standard, widely supported, no framework lock-in
- Matches Go SDK's StreamableHTTPHandler pattern
- Mature API with good documentation
- Lighter than Spring Boot, more standard than Netty

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| Spring WebFlux | Fully reactive, excellent scaling | Heavy dependency, complex setup | Overkill for simple MCP servers |
| Raw Servlet API | Maximum control, minimal deps | Must reimplement MCP protocol layer | Duplicate work, error-prone |
| Netty | High performance, low overhead | Requires custom transport impl | Complexity not justified by perf needs |
| STDIO Transport | Simplest transport | Not HTTP-based, can't use with agents | Doesn't match Go HTTP/SSE implementation |

### 2. Streamable HTTP Transport Implementation

**Question**: How should Java servers implement the MCP Streaming Protocol over HTTP/SSE to match Go's StreamableHTTPHandler?

**Findings**:
- **Go Implementation**: Uses single `/mcp` endpoint handling both HTTP POST requests and SSE responses
- **MCP Protocol**: JSON-RPC 2.0 over HTTP with Server-Sent Events for streaming responses
- **Jakarta Servlet Support**:
  - `HttpServlet` base class for HTTP handling
  - `AsyncContext` for asynchronous processing (required for SSE)
  - Standard request/response API
- **SSE Format**:
  ```
  Content-Type: text/event-stream
  Cache-Control: no-cache
  Connection: keep-alive

  data: {"jsonrpc":"2.0","result":{...},"id":1}\n\n
  ```

**Decision**: Implement custom servlet extending `HttpServlet` with SSE support via `AsyncContext`

**Rationale**:
- Single `/mcp` endpoint matches Go implementation exactly
- `AsyncContext` provides non-blocking SSE streaming
- Clean separation between transport (servlet) and business logic (MCP SDK)
- Standard Servlet API, no custom server required
- Can embed in Jetty, Tomcat, or any servlet container

**Implementation Approach**:
```java
@WebServlet("/mcp")
public class MCPServlet extends HttpServlet {
    private final McpServer mcpServer;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
        AsyncContext asyncContext = req.startAsync();
        // Read JSON-RPC request
        // Delegate to MCP SDK
        // Write SSE response
        asyncContext.complete();
    }
}
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| Embedded Jetty | Full control over server lifecycle | Requires managing server start/stop/config | Adds complexity, not needed |
| Spring Boot | Auto-configuration, production-ready | Heavy (20+ MB), slow startup | Overkill for simple servers |
| Undertow | High perf, lightweight | Less common, smaller ecosystem | Servlet API is more standard |

### 3. mTLS Integration with Existing Certificates

**Question**: How can Java servers use the same PEM certificates generated by the Go cert-gen utility for mTLS?

**Findings**:
- **Go Certificate Format**: PEM-encoded files (ca.crt, server.crt, server.key, client.crt, client.key)
- **Java Certificate API**:
  - `SSLContext` for configuring TLS
  - `KeyStore` for private keys
  - `TrustStore` for trusted CA certificates
  - Native formats: JKS (deprecated), PKCS12 (preferred)
- **PEM Loading Options**:
  1. **BouncyCastle Provider**: Library for reading PEM directly
  2. **Custom PEM Parser**: Parse PEM, convert to Java KeyStore programmatically
  3. **OpenSSL Conversion**: Convert PEM to PKCS12 offline (one-time)
- **mTLS Requirements**:
  - Server presents server.crt signed by ca.crt
  - Server trusts ca.crt for validating client certificates
  - Client presents client.crt (Go coordinator agent)
  - Same behavior as Go mTLS servers

**Decision**: Use Java `SSLContext` with KeyStore/TrustStore loaded from PEM files using BouncyCastle

**Rationale**:
- Reuses existing certificate infrastructure (no Java cert-gen needed)
- BouncyCastle is mature, widely used for PEM operations
- Programmatic loading allows runtime certificate changes
- Maintains identical mTLS handshake behavior as Go servers
- No manual conversion step required

**Implementation Approach**:
```java
// Load CA certificate into TrustStore
TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
KeyStore trustStore = KeyStore.getInstance("JKS");
trustStore.load(null);
trustStore.setCertificateEntry("ca", loadPEMCertificate("ca.crt"));
tmf.init(trustStore);

// Load server key + certificate into KeyStore
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
KeyStore keyStore = KeyStore.getInstance("JKS");
keyStore.load(null);
keyStore.setKeyEntry("server", loadPEMPrivateKey("server.key"), password,
    new Certificate[]{loadPEMCertificate("server.crt")});
kmf.init(keyStore, password);

// Configure SSLContext
SSLContext sslContext = SSLContext.getInstance("TLS");
sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| Java KeyStore (JKS) | Native Java format | Requires converting PEM to JKS | Extra conversion step, less flexible |
| PKCS12 | Modern standard, widely supported | Still requires PEM conversion | Not as convenient as direct PEM loading |
| Manual openssl conversion | One-time operation | Error-prone, not automated | Breaks seamless certificate sharing |

### 4. Gradle Build Integration

**Question**: How should the Java build system integrate with the existing Makefile-based Go build?

**Findings**:
- **Existing Build**: Makefile with targets for `build`, `run-servers`, `run-servers-tls`, `stop-servers`
- **Java Build Tools**: Gradle (DSL-based) vs Maven (XML-based)
- **Gradle Features**:
  - Application plugin: creates executable start scripts
  - Fat JAR support: single executable JAR per server
  - Incremental builds: Gradle daemon caches dependencies
  - Multi-project support: manage 3 servers as sub-projects
- **Integration Strategy**:
  - Makefile invokes Gradle for Java builds
  - Separate `build-java`, `run-java-servers`, `run-java-servers-tls` targets
  - Consistent output structure (JAR files in `build/libs/`)

**Decision**: Multi-project Gradle build with application plugin, orchestrated via Makefile

**Rationale**:
- Application plugin creates OS-specific start scripts (like Go binaries)
- Gradle daemon improves incremental build performance
- Native fat JAR support (single executable per server)
- Makefile provides unified interface for both Go and Java
- Developers use familiar `make build-java` commands

**Build Structure**:
```
java-mcp-servers/
├── build.gradle                 # Root build configuration
├── settings.gradle              # Multi-project settings
├── weather-mcp/
│   └── build.gradle
├── datetime-mcp/
│   └── build.gradle
└── echo-mcp/
    └── build.gradle
```

**Makefile Integration**:
```makefile
build-java:
	cd java-mcp-servers && ./gradlew build

run-java-servers:
	java -jar java-mcp-servers/build/libs/weather-mcp-server.jar &
	java -jar java-mcp-servers/build/libs/datetime-mcp-server.jar &
	java -jar java-mcp-servers/build/libs/echo-mcp-server.jar &
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| Maven | XML-based, mature ecosystem | Less flexible, verbose pom.xml files | Gradle DSL is more concise |
| Single project with multiple mains | Simpler structure | Harder to manage dependencies per server | Less clean separation |
| Gradle multi-module | Best practice for large projects | Overkill for 3 simple servers | Unnecessary complexity |

### 5. JSON Serialization Compatibility

**Question**: How can Java servers produce byte-identical JSON output to Go servers?

**Findings**:
- **Go JSON Marshaling**: Uses `encoding/json` with struct tags
  - Field order: Matches struct field order
  - Null handling: Omits null fields with `omitempty`
  - Timestamp format: RFC3339 (ISO 8601)
  - Number format: No trailing zeros (e.g., `20.5` not `20.50`)
- **Java JSON Libraries**:
  1. **Jackson**: Most popular, highly configurable
  2. **Gson**: Google's library, simpler API
  3. **JSON-B**: Java EE standard (Jakarta JSON Binding)
- **Compatibility Requirements**:
  - Field order must match Go structs
  - ISO 8601 timestamp format
  - No trailing zeros on decimals
  - Consistent null handling

**Decision**: Use Jackson with custom `ObjectMapper` configuration

**Rationale**:
- Jackson has fine-grained control over JSON output format
- Can enforce field order with `@JsonPropertyOrder`
- Custom serializers for timestamp and number formatting
- Supports Java records natively (Java 16+)
- High performance, widely adopted

**Configuration**:
```java
ObjectMapper mapper = new ObjectMapper()
    .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
    .configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, false)
    .setSerializationInclusion(JsonInclude.Include.NON_NULL)
    .setDateFormat(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'"));
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| Gson | Simpler API, good defaults | Less control over output format | Can't guarantee byte-exact match |
| JSON-B | Jakarta EE standard | Less flexible, smaller ecosystem | Harder to customize formatting |
| Manual serialization | Full control | Error-prone, not maintainable | Too much work, defeats purpose of library |

### 6. Logging Strategy

**Question**: How should Java servers log to match Go's structured logging format?

**Findings**:
- **Go Logging**: Uses custom `utils.Info()`, `utils.Debug()` functions with structured fields
- **Java Logging Frameworks**:
  1. **SLF4J + Logback**: Industry standard facade + implementation
  2. **Log4j 2**: Feature-rich, async logging
  3. **java.util.logging (JUL)**: Built-in, basic features
- **Structured Logging**:
  - SLF4J supports MDC (Mapped Diagnostic Context) for structured fields
  - Logback supports JSON formatting
  - Can match Go's log format with custom pattern

**Decision**: SLF4J facade with Logback implementation

**Rationale**:
- SLF4J is de facto standard in Java (facade pattern)
- Logback supports MDC for structured logging (request IDs, etc.)
- Can format logs to match Go's output for consistency
- Mature, well-documented, widely used
- Allows swapping implementations without code changes

**Log Format Example**:
```
2025-10-07 14:30:45.123 INFO  [weather-mcp] WeatherTool - Handling getTemperature request for city: New York
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| java.util.logging | Built-in, no dependencies | Too basic, poor structured logging | Insufficient features |
| Log4j 2 | Powerful, async logging | Security concerns (Log4Shell), heavier | SLF4J+Logback is safer choice |
| System.out.println | Simplest possible | Not production-ready, no levels | Not suitable for servers |

### 7. CLI Argument Parsing

**Question**: How should Java servers parse command-line arguments to match Go's flag package?

**Findings**:
- **Go CLI**: Uses `flag` package with boolean flags (`--tls`), string flags, etc.
- **Java CLI Libraries**:
  1. **Picocli**: Annotation-based, type-safe
  2. **Apache Commons CLI**: Older, imperative API
  3. **JCommander**: Similar to Picocli, less maintained
- **Requirements**:
  - Boolean flag: `--tls` (enable TLS mode)
  - Boolean flag: `--verbose` (enable debug logging)
  - Auto-generated help message

**Decision**: Picocli library

**Rationale**:
- Annotation-based CLI definition (clean, type-safe)
- Supports boolean flags like Go's `flag.Bool()`
- Auto-generates help messages (--help)
- Native GraalVM support for future native compilation
- Modern API, actively maintained

**Usage Example**:
```java
@Command(name = "weather-mcp", description = "Weather MCP Server")
class WeatherServer implements Callable<Integer> {
    @Option(names = "--tls", description = "Enable TLS support")
    boolean useTLS;

    @Option(names = "--verbose", description = "Enable verbose logging")
    boolean verbose;

    public static void main(String[] args) {
        System.exit(new CommandLine(new WeatherServer()).execute(args));
    }
}
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| Apache Commons CLI | Mature, stable | Verbose API, more boilerplate | Less ergonomic than Picocli |
| JCommander | Similar to Picocli | Less actively maintained | Picocli is better supported |
| Manual parsing | No dependencies | Error-prone, tedious | Not worth the effort |

### 8. Testing Strategy

**Question**: How should Java servers be tested to ensure Go compatibility?

**Findings**:
- **Go Testing**: Uses `testing` package with table-driven tests
- **Java Testing Frameworks**:
  1. **JUnit 5**: Modern, supports parameterized tests
  2. **TestNG**: Alternative framework, less common
- **Assertion Libraries**:
  1. **AssertJ**: Fluent assertions, highly readable
  2. **Hamcrest**: Matcher-based assertions
- **Integration Testing**:
  1. **WireMock**: HTTP mocking, can simulate Go coordinator
  2. **Testcontainers**: Docker-based integration tests
- **Test Types Needed**:
  - Unit tests: Tool logic, data models
  - Contract tests: JSON-RPC protocol compliance
  - Integration tests: Full server with HTTP requests
  - Compatibility tests: Byte-exact JSON comparison with Go

**Decision**: JUnit 5 + AssertJ + WireMock for integration tests

**Rationale**:
- JUnit 5 supports parameterized tests (`@ParameterizedTest`) for table-driven tests
- AssertJ provides fluent assertions (`assertThat(x).isEqualTo(y)`)
- WireMock can simulate Go coordinator agent requests
- Can verify byte-exact JSON responses
- Standard tools with excellent IDE support

**Test Structure**:
```java
@ParameterizedTest
@MethodSource("cityTestCases")
void testWeatherToolReturnsValidData(String city) {
    // Table-driven test like Go
}

@Test
void testGoCompatibility() {
    // Start Java server
    // Send same request Go test uses
    // Compare JSON responses byte-by-byte
}
```

**Alternatives Considered**:
| Alternative | Pros | Cons | Why Rejected |
|-------------|------|------|--------------|
| TestNG | Mature, powerful | Less common in modern projects | JUnit 5 is more standard |
| Mockito alone | Good for mocking | Not sufficient for protocol testing | Need HTTP-level testing |
| Manual HTTP clients | Full control | Harder to maintain, more code | WireMock is simpler |
| Testcontainers | True integration testing | Requires Docker, slower | Overkill for these servers |

## Summary of Decisions

| Research Area | Decision | Key Benefit |
|---------------|----------|-------------|
| MCP SDK | v0.14.1 with Jakarta Servlet | Protocol compliance, standard API |
| HTTP/SSE Transport | Custom servlet with AsyncContext | Matches Go implementation |
| mTLS Certificates | BouncyCastle PEM loading | Reuses Go certificates |
| Build System | Gradle + Makefile integration | Unified build interface |
| JSON Serialization | Jackson with custom config | Byte-exact compatibility |
| Logging | SLF4J + Logback | Structured logging like Go |
| CLI Parsing | Picocli | Type-safe, matches Go flags |
| Testing | JUnit 5 + AssertJ + WireMock | Table-driven + integration tests |

## Dependencies Summary

```gradle
dependencies {
    // MCP SDK
    implementation 'io.github.modelcontextprotocol:mcp-server:0.14.1'

    // HTTP/Servlet
    implementation 'jakarta.servlet:jakarta.servlet-api:5.0.0'
    implementation 'org.eclipse.jetty:jetty-server:11.0.15'
    implementation 'org.eclipse.jetty:jetty-servlet:11.0.15'

    // TLS/Certificates
    implementation 'org.bouncycastle:bcprov-jdk18on:1.76'
    implementation 'org.bouncycastle:bcpkix-jdk18on:1.76'

    // JSON
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.2'

    // CLI
    implementation 'info.picocli:picocli:4.7.5'

    // Logging
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation 'ch.qos.logback:logback-classic:1.4.11'

    // Testing
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    testImplementation 'org.assertj:assertj-core:3.24.2'
    testImplementation 'com.github.tomakehurst:wiremock:3.0.1'
}
```

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| JSON format mismatch | Medium | High | Extensive compatibility tests, byte-exact comparison |
| mTLS handshake failure | Low | High | Test with Go coordinator, verify certificate loading |
| Performance degradation | Low | Medium | Keep servers lightweight, benchmark response times |
| MCP SDK breaking changes | Low | Medium | Pin to v0.14.1, monitor SDK releases |
| Port conflicts | Medium | Low | Document port configuration, provide error messages |

## Next Steps

1. ✅ All research complete
2. → Proceed to Phase 1: Design & Contracts
3. → Create data-model.md with Java record definitions
4. → Generate API contracts in /contracts/ directory
5. → Write quickstart.md guide
6. → Update CLAUDE.md with Java context

---
*Research completed: 2025-10-07*
*Ready for Phase 1: Design & Contracts*
