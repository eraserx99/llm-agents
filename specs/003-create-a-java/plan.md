# Implementation Plan: Java MCP Servers

**Branch**: `003-create-a-java` | **Date**: 2025-10-07 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-create-a-java/spec.md`

## Execution Flow (/plan command scope)
```
1. Load feature spec from Input path
   → SUCCESS: Loaded spec.md with 20 functional requirements
2. Fill Technical Context (scan for NEEDS CLARIFICATION)
   → Project Type: single (Java MCP servers alongside Go codebase)
   → Structure Decision: Separate Java module with Gradle build
3. Fill the Constitution Check section
   → Constitution template not customized, using Go standards as baseline
4. Evaluate Constitution Check section
   → No violations detected
   → Update Progress Tracking: Initial Constitution Check ✓
5. Execute Phase 0 → research.md
   → Researched MCP Java SDK v0.14.1 capabilities
   → Researched Streamable HTTP transport implementation
   → Researched mTLS integration patterns
6. Execute Phase 1 → contracts, data-model.md, quickstart.md, CLAUDE.md
   → Generated data models for Weather, DateTime, Echo entities
   → Created MCP protocol contracts (JSON-RPC 2.0)
   → Generated quickstart guide for Java servers
   → Updated CLAUDE.md with Java context
7. Re-evaluate Constitution Check section
   → No new violations after design
   → Update Progress Tracking: Post-Design Constitution Check ✓
8. Plan Phase 2 → Describe task generation approach
   → 30-35 tasks estimated for TDD implementation
9. STOP - Ready for /tasks command
```

**IMPORTANT**: The /plan command STOPS at step 7. Phases 2-4 are executed by other commands:
- Phase 2: /tasks command creates tasks.md
- Phase 3-4: Implementation execution (manual or via tools)

## Summary
Create three Java-based MCP servers (weather, datetime, echo) that are 100% protocol-compatible with existing Go coordinator agents. The Java servers implement the MCP Streaming Protocol using the official MCP Java SDK (v0.14.1), support optional mTLS authentication using certificates generated by the existing Go cert-gen utility, and provide identical JSON I/O formats. Integration with existing build system (Makefile), documentation (README.md), and IDE configuration (VS Code) ensures seamless developer experience when switching between Go and Java server implementations.

## Technical Context
**Language/Version**: Java 21 (LTS) or greater
**Primary Dependencies**:
- MCP Java SDK v0.14.1 (io.github.modelcontextprotocol:mcp-server)
- Jakarta Servlet API (for HTTP/SSE transport)
- SLF4J with Logback (logging, matching Go's structured logging)
- Picocli (CLI argument parsing, matching Go's flag package)
- Gson or Jackson (JSON serialization)

**Storage**: N/A (stateless servers with simulated data)
**Testing**: JUnit 5, AssertJ for assertions, WireMock for MCP protocol testing
**Target Platform**: JVM 21+ on Linux/macOS/Windows, containerizable
**Project Type**: single (Java module alongside Go codebase)
**Performance Goals**:
- Handle 100+ concurrent requests per server
- Response time <50ms for simulated data operations
- Memory footprint <128MB per server process

**Constraints**:
- Must use same certificate files as Go servers (./certs/)
- Must bind to same default ports (8081/8443, 8082/8444, 8083/8445)
- Must read same environment variables (TLS_ENABLED, TLS_DEMO_MODE, TLS_CERT_DIR)
- Must produce byte-identical JSON responses to Go servers
- Zero changes allowed to Go coordinator agent code

**Scale/Scope**:
- 3 MCP servers (weather, datetime, echo)
- ~2000 LOC per server (Java is more verbose than Go)
- 15-20 integration tests for protocol compatibility
- Support for 100+ US cities (matching Go datetime server)

**Additional Context from User**:
- Use Streamable Transport for HTTP/SSE implementation
- Reuse certificates generated by Go cert-gen program (no Java cert generator needed)
- Implement mTLS accordingly using existing certificate infrastructure

## Constitution Check
*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

The project constitution is not customized (contains template placeholders). Using Go development standards from CLAUDE.md as baseline principles:

- [x] **Go Standard BP-1**: Ask clarifying questions → PASS (user provided explicit requirements)
- [x] **Go Standard CS-5**: Use input structs for >2 args → PASS (Java: use builder pattern or parameter objects)
- [x] **Go Standard ERR-1**: Wrap errors with context → PASS (Java: use exception chaining)
- [x] **Go Standard CTX-1**: Context as first parameter → PASS (Java: ExecutionContext pattern)
- [x] **Go Standard T-1**: Table-driven tests → PASS (Java: @ParameterizedTest with @MethodSource)
- [x] **Go Standard API-1**: Document exported items → PASS (Java: Javadoc for public APIs)
- [x] **Go Standard SEC-1**: Validate inputs, set timeouts → PASS (Java: validation + Socket timeouts)
- [x] **Go Standard CI-1**: Lint, test on every PR → PASS (Gradle checkstyle, spotbugs, test tasks)

**Additional Java-specific Gates**:
- [x] **Java 21 Features**: Use records for immutable DTOs (WeatherData, DateTimeData, EchoData)
- [x] **Java Best Practices**: Prefer composition over inheritance
- [x] **Java Testing**: Unit tests with JUnit 5, integration tests with embedded servers
- [x] **Java Security**: Use Java KeyStore/TrustStore for certificate management

**Result**: PASS - No constitutional violations, all gates satisfied

## Project Structure

### Documentation (this feature)
```
specs/003-create-a-java/
├── plan.md              # This file (/plan command output)
├── research.md          # Phase 0 output (/plan command)
├── data-model.md        # Phase 1 output (/plan command)
├── quickstart.md        # Phase 1 output (/plan command)
├── contracts/           # Phase 1 output (/plan command)
│   ├── mcp-protocol.json       # JSON-RPC 2.0 MCP protocol spec
│   ├── weather-api.json        # Weather MCP server contract
│   ├── datetime-api.json       # DateTime MCP server contract
│   └── echo-api.json           # Echo MCP server contract
└── tasks.md             # Phase 2 output (/tasks command - NOT created by /plan)
```

### Source Code (repository root)
```
# Java module structure (new)
java-mcp-servers/
├── build.gradle                # Gradle build configuration
├── settings.gradle             # Gradle settings
├── gradle/                     # Gradle wrapper
│   └── wrapper/
├── gradlew                     # Gradle wrapper script (Unix)
├── gradlew.bat                 # Gradle wrapper script (Windows)
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── llmagents/
│   │   │           └── mcp/
│   │   │               ├── common/          # Shared utilities
│   │   │               │   ├── config/      # Config classes
│   │   │               │   ├── tls/         # TLS/mTLS support
│   │   │               │   └── logging/     # Logging utilities
│   │   │               ├── weather/         # Weather server
│   │   │               │   ├── WeatherServer.java
│   │   │               │   ├── WeatherTool.java
│   │   │               │   └── model/
│   │   │               │       └── WeatherData.java (record)
│   │   │               ├── datetime/        # DateTime server
│   │   │               │   ├── DateTimeServer.java
│   │   │               │   ├── DateTimeTool.java
│   │   │               │   └── model/
│   │   │               │       └── DateTimeData.java (record)
│   │   │               └── echo/            # Echo server
│   │   │                   ├── EchoServer.java
│   │   │                   ├── EchoTool.java
│   │   │                   └── model/
│   │   │                       └── EchoData.java (record)
│   │   └── resources/
│   │       └── logback.xml              # Logging configuration
│   └── test/
│       └── java/
│           └── com/
│               └── llmagents/
│                   └── mcp/
│                       ├── integration/     # Integration tests
│                       │   ├── WeatherServerTest.java
│                       │   ├── DateTimeServerTest.java
│                       │   └── EchoServerTest.java
│                       └── unit/            # Unit tests
│                           ├── WeatherToolTest.java
│                           ├── DateTimeToolTest.java
│                           └── EchoToolTest.java
└── build/                      # Build output (gitignored)
    └── libs/
        ├── weather-mcp-server.jar
        ├── datetime-mcp-server.jar
        └── echo-mcp-server.jar

# Existing Go structure (unchanged)
cmd/
internal/
certs/          # Shared certificate directory for both Go and Java
bin/            # Go binaries
```

**Structure Decision**: Single repository with separate Java module. Java servers coexist with Go implementation, sharing certificates and configuration. Gradle handles Java build, Makefile orchestrates both Go and Java builds.

## Phase 0: Outline & Research

### Research Tasks Completed

1. **MCP Java SDK Capabilities** ✓
   - **Decision**: Use MCP Java SDK v0.14.1 with Jakarta Servlet transport
   - **Rationale**:
     - Official SDK ensures protocol compliance
     - Jakarta Servlet provides standard HTTP/SSE implementation
     - Matches Go SDK's StreamableHTTPHandler pattern
     - Mature, well-documented API
   - **Alternatives Considered**:
     - Spring WebFlux: More complex, heavier dependency footprint
     - Raw Servlet API: More control but requires reimplementing MCP protocol layer
     - Netty: High performance but overkill for this use case

2. **Streamable HTTP Transport Implementation** ✓
   - **Decision**: Implement custom servlet extending HttpServlet with SSE support
   - **Rationale**:
     - Go servers use single /mcp endpoint for HTTP POST + SSE responses
     - Jakarta Servlet allows async processing for SSE streams
     - Aligns with MCP Streaming Protocol specification
     - Provides clean separation between transport and business logic
   - **Alternatives Considered**:
     - Embedded Jetty: Requires server lifecycle management
     - Spring Boot: Too heavy for simple MCP servers
     - Undertow: Less common, smaller ecosystem

3. **mTLS Integration with Existing Certificates** ✓
   - **Decision**: Use Java SSLContext with KeyStore/TrustStore loaded from PEM files
   - **Rationale**:
     - Go cert-gen creates PEM format certificates (ca.crt, server.crt, server.key, client.crt, client.key)
     - Java can load PEM files using BouncyCastle or custom loaders
     - Reuses existing certificate infrastructure (no Java cert-gen needed)
     - Maintains identical mTLS handshake behavior
   - **Alternatives Considered**:
     - Java KeyStore (JKS): Would require converting PEM to JKS
     - PKCS12: Better than JKS but still requires conversion
     - Direct PEM loading: Simpler, matches Go's approach

4. **Gradle Build Integration** ✓
   - **Decision**: Multi-project Gradle build with application plugin
   - **Rationale**:
     - Application plugin creates executable start scripts (like Go binaries)
     - Gradle daemon speeds up incremental builds
     - Native support for fat JARs and distribution zips
     - Integrates with existing Makefile via make targets
   - **Alternatives Considered**:
     - Maven: XML-based, less flexible than Gradle DSL
     - Single JAR with main classes: Harder to manage multiple servers
     - Gradle multi-module: Overkill for 3 simple servers

5. **JSON Serialization Compatibility** ✓
   - **Decision**: Use Jackson with custom ObjectMapper configuration
   - **Rationale**:
     - Jackson widely adopted, high performance
     - Fine-grained control over JSON output format
     - Can match Go's JSON marshalling exactly (field order, null handling, timestamp format)
     - Supports Java records natively
   - **Alternatives Considered**:
     - Gson: Simpler but less control over output format
     - JSON-B: Java EE standard but less flexible
     - Manual serialization: Error-prone, not maintainable

6. **Logging Strategy** ✓
   - **Decision**: SLF4J facade with Logback implementation
   - **Rationale**:
     - Matches Go's structured logging approach
     - SLF4J is de facto standard in Java
     - Logback supports MDC (Mapped Diagnostic Context) for request IDs
     - Can format logs to match Go's output for consistency
   - **Alternatives Considered**:
     - java.util.logging: Too basic, poor structured logging support
     - Log4j 2: Powerful but heavier, security concerns
     - System.out.println: Not suitable for production

7. **CLI Argument Parsing** ✓
   - **Decision**: Picocli library
   - **Rationale**:
     - Annotation-based, type-safe CLI definition
     - Supports boolean flags (--tls) like Go's flag package
     - Auto-generates help messages
     - Native GraalVM support (future containerization)
   - **Alternatives Considered**:
     - Apache Commons CLI: Older, more verbose API
     - JCommander: Less actively maintained
     - Manual parsing: Error-prone

8. **Testing Strategy** ✓
   - **Decision**: JUnit 5 + AssertJ + WireMock for integration tests
   - **Rationale**:
     - JUnit 5 is modern, supports parameterized tests (table-driven)
     - AssertJ provides fluent assertions
     - WireMock can simulate Go coordinator agent requests
     - Can verify byte-exact JSON responses
   - **Alternatives Considered**:
     - TestNG: Less common in modern projects
     - Mockito alone: Not sufficient for protocol testing
     - Manual HTTP clients: Harder to maintain

**Output**: research.md file generated with all decisions documented

## Phase 1: Design & Contracts

### 1. Data Model Design

**Entities Extracted from Spec** (documented in `data-model.md`):

#### WeatherData (Java Record)
```java
public record WeatherData(
    double temperature,    // Celsius, range 20.0-45.0
    String unit,          // Always "°C"
    String description,   // One of: Sunny, Partly cloudy, Cloudy, Light rain, Clear
    String city,          // City name from request
    String timestamp      // ISO 8601 format (e.g., "2024-09-23T14:30:45Z")
) {
    // Validation in compact constructor
    public WeatherData {
        if (temperature < -50 || temperature > 60) {
            throw new IllegalArgumentException("Invalid temperature");
        }
        // ... other validations
    }
}
```

#### DateTimeData (Java Record)
```java
public record DateTimeData(
    String localTime,     // Format: "2006-01-02 15:04:05"
    String timezone,      // IANA timezone (e.g., "America/New_York")
    String utcOffset,     // Format: "+05:00" or "-05:00"
    String city,          // City name from request
    String timestamp      // ISO 8601 format
) {
    // Supported cities: New York, Los Angeles, Chicago, Denver, London, Tokyo, etc.
}
```

#### EchoData (Java Record)
```java
public record EchoData(
    String originalText,  // Input text
    String echoText,      // Same as originalText
    String timestamp      // ISO 8601 format
) {}
```

#### MCPRequest (JSON-RPC 2.0)
```java
public record MCPRequest(
    String jsonrpc,       // Always "2.0"
    String method,        // "tools/list" or "tools/call"
    Object params,        // Method-specific parameters
    Object id             // String or number
) {}
```

#### MCPResponse (JSON-RPC 2.0)
```java
public record MCPResponse(
    String jsonrpc,       // Always "2.0"
    Object result,        // Response data (or null if error)
    MCPError error,       // Error details (or null if success)
    Object id             // Matches request id
) {}
```

### 2. API Contracts

**Generated Contracts** (in `/contracts/` directory):

#### mcp-protocol.json
JSON-RPC 2.0 base protocol specification with:
- Request/response message structure
- Error codes (-32700 parse error, -32600 invalid request, -32601 method not found)
- SSE event format

#### weather-api.json
```json
{
  "endpoint": "/mcp",
  "tool": "getTemperature",
  "method": "tools/call",
  "request": {
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "getTemperature",
      "arguments": {
        "city": "string (required)"
      }
    },
    "id": 1
  },
  "response": {
    "jsonrpc": "2.0",
    "result": {
      "content": [{
        "type": "text",
        "text": "Weather in {city}: {temp}°C, {description}"
      }]
    },
    "id": 1
  }
}
```

#### datetime-api.json
Similar structure for `getDateTime` tool with city parameter.

#### echo-api.json
Similar structure for `echo` tool with text parameter.

### 3. Contract Tests (TDD - Must Fail Initially)

**Test Files Created** (in `src/test/java/.../integration/`):

- `WeatherServerProtocolTest.java`: Verifies JSON-RPC message format
- `DateTimeServerProtocolTest.java`: Verifies JSON-RPC message format
- `EchoServerProtocolTest.java`: Verifies JSON-RPC message format
- `WeatherGoCompatibilityTest.java`: Byte-exact JSON comparison with Go server
- `DateTimeGoCompatibilityTest.java`: Byte-exact JSON comparison with Go server
- `EchoGoCompatibilityTest.java`: Byte-exact JSON comparison with Go server

Each test:
- Sends JSON-RPC request to Java server
- Captures JSON response
- Compares with expected Go server response
- Validates JSON schema compliance
- Tests edge cases (unsupported city, malformed JSON, etc.)

### 4. Integration Test Scenarios

**Extracted from User Stories**:

1. **Basic Tool Call Test**:
   - Given: Java weather server running on port 8081
   - When: Client sends `{"jsonrpc":"2.0","method":"tools/call","params":{"name":"getTemperature","arguments":{"city":"New York"}},"id":1}`
   - Then: Response contains temperature, unit="°C", city="New York", valid timestamp

2. **mTLS Connection Test**:
   - Given: Java servers started with --tls flag, certificates in ./certs/
   - When: Client connects using client.crt and client.key
   - Then: TLS handshake succeeds, request processes normally

3. **SSE Streaming Test**:
   - Given: Java server with long-running tool
   - When: Client connects to /mcp endpoint
   - Then: Response uses SSE format with proper `data:` events

4. **Port Configuration Test**:
   - Given: Environment variables WEATHER_MCP_PORT=9000, WEATHER_MCP_TLS_PORT=9443
   - When: Java weather server starts
   - Then: Server binds to ports 9000 (HTTP) and 9443 (HTTPS)

5. **Error Handling Test**:
   - Given: Java server receives malformed JSON
   - When: Request has invalid `jsonrpc` field
   - Then: Server returns JSON-RPC error response with code -32600

### 5. Quickstart Guide

**Generated `quickstart.md`**:

```markdown
# Java MCP Servers Quickstart

## Prerequisites
- Java 21 or greater
- Gradle (bundled via wrapper)
- Certificates generated (run `make generate-certs`)

## Build
```bash
# Build all Java servers
make build-java

# Or use Gradle directly
cd java-mcp-servers
./gradlew build
```

## Run Servers

### HTTP Mode
```bash
# Start all Java servers (HTTP)
make run-java-servers

# Or individually
java -jar java-mcp-servers/build/libs/weather-mcp-server.jar
java -jar java-mcp-servers/build/libs/datetime-mcp-server.jar
java -jar java-mcp-servers/build/libs/echo-mcp-server.jar
```

### HTTPS Mode (mTLS)
```bash
# Start all Java servers (HTTPS)
export TLS_ENABLED=true
export TLS_DEMO_MODE=true
export TLS_CERT_DIR=./certs
make run-java-servers-tls

# Or individually
java -jar java-mcp-servers/build/libs/weather-mcp-server.jar --tls
```

## Test Connectivity
```bash
# Test Java weather server (should work with Go coordinator)
./bin/llm-agents -city "New York" -query "What's the temperature?"

# Verify JSON output matches Go server
curl http://localhost:8081/mcp -X POST -d '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"getTemperature","arguments":{"city":"Tokyo"}},"id":1}'
```

## Validate
- [ ] Build completes without errors
- [ ] Servers start and bind to correct ports
- [ ] Health check endpoints respond
- [ ] Go coordinator agent can connect and query
- [ ] mTLS handshake succeeds in HTTPS mode
- [ ] JSON responses match Go server format exactly
```

### 6. Agent Context Update

**Update CLAUDE.md** (incremental O(1) operation):

Run update script:
```bash
.specify/scripts/bash/update-agent-context.sh claude
```

Expected additions to CLAUDE.md:
- New "Active Feature" section: Comprehensive Java MCP Servers (003-create-a-java)
- Language/Framework: Java 21 with MCP Java SDK v0.14.1
- Architecture: Dual-language MCP servers (Go + Java)
- Key Components: 3 Java MCP servers with identical functionality
- Recent Changes: Add Java implementation as third entry

**Output**: data-model.md, /contracts/*, quickstart.md, CLAUDE.md updated

## Phase 2: Task Planning Approach
*This section describes what the /tasks command will do - DO NOT execute during /plan*

**Task Generation Strategy**:
1. Load `.specify/templates/tasks-template.md` as base structure
2. Generate tasks from Phase 1 artifacts:
   - Each contract (weather, datetime, echo) → contract test task [P]
   - Each data model (WeatherData, DateTimeData, EchoData) → model creation task [P]
   - Each server (weather, datetime, echo) → tool implementation task
   - Common utilities (TLS, logging, config) → shared library tasks [P]
   - Integration tests → compatibility test tasks
   - Build configuration → Gradle setup tasks
   - Documentation → README/Makefile update tasks

3. Task ordering (TDD order):
   - Phase A: Setup & Configuration [P]
     - Gradle project structure
     - Dependency configuration
     - Shared utilities (logging, config, TLS)
   - Phase B: Data Models [P]
     - WeatherData record + tests
     - DateTimeData record + tests
     - EchoData record + tests
     - MCP protocol models + tests
   - Phase C: Contract Tests (must fail initially)
     - Weather contract tests
     - DateTime contract tests
     - Echo contract tests
   - Phase D: Tool Implementation (make tests pass)
     - Weather tool + handler
     - DateTime tool + handler
     - Echo tool + handler
   - Phase E: Server Assembly
     - Weather server main class + servlet
     - DateTime server main class + servlet
     - Echo server main class + servlet
   - Phase F: Integration Testing
     - Go compatibility tests
     - mTLS integration tests
     - Port configuration tests
   - Phase G: Build System Integration
     - Makefile targets (build-java, run-java-servers, etc.)
     - VS Code launch configurations
     - README documentation updates

**Ordering Strategy**:
- TDD: Tests before implementation (Phase C before Phase D)
- Dependency: Models before tools, tools before servers
- Parallelization: Mark [P] for independent tasks (models, contract tests)
- Sequential: Server assembly depends on tools, integration tests depend on servers

**Estimated Output**: 30-35 numbered, ordered tasks in tasks.md

**Task Template Example**:
```markdown
### Task 15: Implement Weather Tool Handler
- **Type**: Implementation
- **Dependencies**: Tasks 5, 10, 12 (WeatherData, contract test, MCP tool interface)
- **Parallel**: No (depends on shared utilities)
- **TDD Status**: Make WeatherContractTest pass
- **Validation**:
  - Weather contract test passes
  - Returns simulated data in 20-45°C range
  - JSON output matches Go server format
  - Tool registered with MCP server correctly
```

**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan

## Phase 3+: Future Implementation
*These phases are beyond the scope of the /plan command*

**Phase 3**: Task execution (/tasks command creates tasks.md)
**Phase 4**: Implementation (execute tasks.md following TDD + Go standards)
**Phase 5**: Validation (run tests, execute quickstart.md, compatibility testing with Go coordinator)

## Complexity Tracking
*No constitutional violations detected - section left empty*

## Progress Tracking
*This checklist is updated during execution flow*

**Phase Status**:
- [x] Phase 0: Research complete (/plan command)
- [x] Phase 1: Design complete (/plan command)
- [x] Phase 2: Task planning complete (/plan command - describe approach only)
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [x] Post-Design Constitution Check: PASS
- [x] All NEEDS CLARIFICATION resolved
- [x] Complexity deviations documented (N/A - no deviations)

---
*Based on Go Development Standards from CLAUDE.md - No project-specific constitution found*
